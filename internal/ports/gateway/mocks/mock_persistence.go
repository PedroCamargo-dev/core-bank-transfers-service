// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/PedroCamargo-dev/core-bank-transfers-service/internal/ports/gateway/persistence (interfaces: TransferRepository,OutboxRepository,InboxRepository,UnitOfWork)
//
// Generated by this command:
//
//	mockgen -destination=mock_persistence.go -package=mocks github.com/PedroCamargo-dev/core-bank-transfers-service/internal/ports/gateway/persistence TransferRepository,OutboxRepository,InboxRepository,UnitOfWork
//

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	domain_transfer "github.com/PedroCamargo-dev/core-bank-transfers-service/internal/domain/transfer"
	port_persistence "github.com/PedroCamargo-dev/core-bank-transfers-service/internal/ports/gateway/persistence"
	gomock "go.uber.org/mock/gomock"
)

// MockTransferRepository is a mock of TransferRepository interface.
type MockTransferRepository struct {
	ctrl     *gomock.Controller
	recorder *MockTransferRepositoryMockRecorder
	isgomock struct{}
}

// MockTransferRepositoryMockRecorder is the mock recorder for MockTransferRepository.
type MockTransferRepositoryMockRecorder struct {
	mock *MockTransferRepository
}

// NewMockTransferRepository creates a new mock instance.
func NewMockTransferRepository(ctrl *gomock.Controller) *MockTransferRepository {
	mock := &MockTransferRepository{ctrl: ctrl}
	mock.recorder = &MockTransferRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockTransferRepository) EXPECT() *MockTransferRepositoryMockRecorder {
	return m.recorder
}

// Create mocks base method.
func (m *MockTransferRepository) Create(ctx context.Context, t *domain_transfer.Transfer, requestHash string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Create", ctx, t, requestHash)
	ret0, _ := ret[0].(error)
	return ret0
}

// Create indicates an expected call of Create.
func (mr *MockTransferRepositoryMockRecorder) Create(ctx, t, requestHash any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Create", reflect.TypeOf((*MockTransferRepository)(nil).Create), ctx, t, requestHash)
}

// GetByID mocks base method.
func (m *MockTransferRepository) GetByID(ctx context.Context, transferID string) (*port_persistence.StoredTransfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByID", ctx, transferID)
	ret0, _ := ret[0].(*port_persistence.StoredTransfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByID indicates an expected call of GetByID.
func (mr *MockTransferRepositoryMockRecorder) GetByID(ctx, transferID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByID", reflect.TypeOf((*MockTransferRepository)(nil).GetByID), ctx, transferID)
}

// GetByIdempotencyKey mocks base method.
func (m *MockTransferRepository) GetByIdempotencyKey(ctx context.Context, key string) (*port_persistence.StoredTransfer, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetByIdempotencyKey", ctx, key)
	ret0, _ := ret[0].(*port_persistence.StoredTransfer)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetByIdempotencyKey indicates an expected call of GetByIdempotencyKey.
func (mr *MockTransferRepositoryMockRecorder) GetByIdempotencyKey(ctx, key any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetByIdempotencyKey", reflect.TypeOf((*MockTransferRepository)(nil).GetByIdempotencyKey), ctx, key)
}

// MockOutboxRepository is a mock of OutboxRepository interface.
type MockOutboxRepository struct {
	ctrl     *gomock.Controller
	recorder *MockOutboxRepositoryMockRecorder
	isgomock struct{}
}

// MockOutboxRepositoryMockRecorder is the mock recorder for MockOutboxRepository.
type MockOutboxRepositoryMockRecorder struct {
	mock *MockOutboxRepository
}

// NewMockOutboxRepository creates a new mock instance.
func NewMockOutboxRepository(ctrl *gomock.Controller) *MockOutboxRepository {
	mock := &MockOutboxRepository{ctrl: ctrl}
	mock.recorder = &MockOutboxRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockOutboxRepository) EXPECT() *MockOutboxRepositoryMockRecorder {
	return m.recorder
}

// DequeueBatch mocks base method.
func (m *MockOutboxRepository) DequeueBatch(ctx context.Context, limit int) ([]port_persistence.OutboxMessage, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DequeueBatch", ctx, limit)
	ret0, _ := ret[0].([]port_persistence.OutboxMessage)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DequeueBatch indicates an expected call of DequeueBatch.
func (mr *MockOutboxRepositoryMockRecorder) DequeueBatch(ctx, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DequeueBatch", reflect.TypeOf((*MockOutboxRepository)(nil).DequeueBatch), ctx, limit)
}

// Enqueue mocks base method.
func (m *MockOutboxRepository) Enqueue(ctx context.Context, msg port_persistence.OutboxMessage) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Enqueue", ctx, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Enqueue indicates an expected call of Enqueue.
func (mr *MockOutboxRepositoryMockRecorder) Enqueue(ctx, msg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enqueue", reflect.TypeOf((*MockOutboxRepository)(nil).Enqueue), ctx, msg)
}

// MarkPublished mocks base method.
func (m *MockOutboxRepository) MarkPublished(ctx context.Context, messageID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkPublished", ctx, messageID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkPublished indicates an expected call of MarkPublished.
func (mr *MockOutboxRepositoryMockRecorder) MarkPublished(ctx, messageID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkPublished", reflect.TypeOf((*MockOutboxRepository)(nil).MarkPublished), ctx, messageID)
}

// MockInboxRepository is a mock of InboxRepository interface.
type MockInboxRepository struct {
	ctrl     *gomock.Controller
	recorder *MockInboxRepositoryMockRecorder
	isgomock struct{}
}

// MockInboxRepositoryMockRecorder is the mock recorder for MockInboxRepository.
type MockInboxRepositoryMockRecorder struct {
	mock *MockInboxRepository
}

// NewMockInboxRepository creates a new mock instance.
func NewMockInboxRepository(ctrl *gomock.Controller) *MockInboxRepository {
	mock := &MockInboxRepository{ctrl: ctrl}
	mock.recorder = &MockInboxRepositoryMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockInboxRepository) EXPECT() *MockInboxRepositoryMockRecorder {
	return m.recorder
}

// MarkFailed mocks base method.
func (m *MockInboxRepository) MarkFailed(ctx context.Context, consumer, messageID, errMsg string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkFailed", ctx, consumer, messageID, errMsg)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkFailed indicates an expected call of MarkFailed.
func (mr *MockInboxRepositoryMockRecorder) MarkFailed(ctx, consumer, messageID, errMsg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkFailed", reflect.TypeOf((*MockInboxRepository)(nil).MarkFailed), ctx, consumer, messageID, errMsg)
}

// MarkProcessed mocks base method.
func (m *MockInboxRepository) MarkProcessed(ctx context.Context, consumer, messageID string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "MarkProcessed", ctx, consumer, messageID)
	ret0, _ := ret[0].(error)
	return ret0
}

// MarkProcessed indicates an expected call of MarkProcessed.
func (mr *MockInboxRepositoryMockRecorder) MarkProcessed(ctx, consumer, messageID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "MarkProcessed", reflect.TypeOf((*MockInboxRepository)(nil).MarkProcessed), ctx, consumer, messageID)
}

// TryInsert mocks base method.
func (m *MockInboxRepository) TryInsert(ctx context.Context, consumer, messageID, messageType, correlationID string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TryInsert", ctx, consumer, messageID, messageType, correlationID)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TryInsert indicates an expected call of TryInsert.
func (mr *MockInboxRepositoryMockRecorder) TryInsert(ctx, consumer, messageID, messageType, correlationID any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TryInsert", reflect.TypeOf((*MockInboxRepository)(nil).TryInsert), ctx, consumer, messageID, messageType, correlationID)
}

// MockUnitOfWork is a mock of UnitOfWork interface.
type MockUnitOfWork struct {
	ctrl     *gomock.Controller
	recorder *MockUnitOfWorkMockRecorder
	isgomock struct{}
}

// MockUnitOfWorkMockRecorder is the mock recorder for MockUnitOfWork.
type MockUnitOfWorkMockRecorder struct {
	mock *MockUnitOfWork
}

// NewMockUnitOfWork creates a new mock instance.
func NewMockUnitOfWork(ctrl *gomock.Controller) *MockUnitOfWork {
	mock := &MockUnitOfWork{ctrl: ctrl}
	mock.recorder = &MockUnitOfWorkMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockUnitOfWork) EXPECT() *MockUnitOfWorkMockRecorder {
	return m.recorder
}

// WithinTx mocks base method.
func (m *MockUnitOfWork) WithinTx(ctx context.Context, fn func(context.Context) error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WithinTx", ctx, fn)
	ret0, _ := ret[0].(error)
	return ret0
}

// WithinTx indicates an expected call of WithinTx.
func (mr *MockUnitOfWorkMockRecorder) WithinTx(ctx, fn any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WithinTx", reflect.TypeOf((*MockUnitOfWork)(nil).WithinTx), ctx, fn)
}
